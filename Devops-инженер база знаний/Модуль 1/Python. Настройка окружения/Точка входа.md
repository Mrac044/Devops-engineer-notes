## Точка входа для приложения
**Точка входа** — исполняемый файл, который запускается во время запуска приложения, состоящего из множества модулей.
==Точку входа, как и прочие исполняемые файлы, принято располагать в директории _scripts_.==

*Пример точки входа:*
```python
# file: my_application/module.py
def greet():
    print('Welcome to my application!')

# file: my_application/scripts/main.py
from my_application.module import greet


def main():
    greet()


main()
```
- _my_application/module.py_ — определена функция, выводящая сообщение в консоль
- _my_application/scripts/main.py_ — импортируется и вызывается функция

==А сами исполняемые файлы часто называют _скриптами_. Также принято все необходимые вызовы делать внутри `main()`, функции без аргументов. И уже вызывая эту функцию, мы запускаем приложение.== #Shell 
```
uv run python3 -m my_application.scripts.main
Welcome to my application!
```
- ==Флаг `-m` означает "вызвать файл как модуль".==
- ==Путь до модуля нужно передавать в формате через точку, начиная от корня проекта.==

## Специальная переменная `__name__`
==В проекте бывают несколько точек входа. Каждая может работать как отдельное приложение и при этом использовать общую логику. Обычно в точке входа происходит вызов одной функции. Могут быть исключения, но всегда лучше стремиться к вызову одной единственной функции.==

Создадим еще один скрипт и импортируем в него предыдущий:

```python
# file: my_application/scripts/second_script.py
from my_application.scripts.main import main


def second_main():
    main()


second_main()
```

Запустим его:
#Shell 
```
uv run python3 -m my_application.scripts.second_script
Welcome to my application!
Welcome to my application!
```
==Чтобы импортировать функцию из модуля, интерпретатор читает и загружает модуль полностью. В этот момент будут выполнены все определения и **вызовы** на уровне модуля.==

Нам нужно как-то различать ситуации двух типов:
- Модуль работает как скрипт — выполняем вызовы
- Модуль импортируется — не выполняем вызовы

Для решения этой задачи используется `__name__`

#Собеседования **`__name__`** - специальная переменная, которая загружается интерпретатором на старте. Как правило, в коде  имеют специальный смысл

Посмотрим, что хранит переменная `__name__` в каждом конкретном случае:
- Если происходит запуск в качестве скрипта, то переменная получает специальное значение — строку `'__main__'`
- Если происходит обычный импорт, то эта переменная содержит полное имя модуля

Перепишем первый скрипт `main.py` с применением этого нового знания:
```python
from my_application.module import greet

def main():
    greet()


if __name__ == "__main__":
    main()
```
И проверим:
#Shell 
```
uv run python3 -m my_application.scripts.second_script
Welcome to my application!
```
Сообщение вывелось один раз, ведь условие `if __name__ == "__main__":` при импорте не выполнится, и функция `main()` не вызовется.
## uv и точка входа
Чтобы вечно не вводить полный путь до точки входа, в uv можно настроить проект так, чтобы запускать его одной командой 
`uv run <точка-входа>`.
Для начала нужно отредактировать файл конфигурации проекта _pyproject.toml_:

```
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["my_application"]

[project.scripts]
my-app = "my_application.scripts.main:main"
```

- Добавляем `[build-system]`   и `[xx.build.targets.wheel]` которые указывают менеджеру, что наш проект это **пакет** со своими импортами и точкой входа, при следующем запуске uv также установит проект в виртуальное окружение

- `[project.scripts]` - указывает на точки входа в проекте, название которой записывается через дефис, а путь до неё указывается как полный путь через точку, до скрипта и после двоеточия сама функция запуска

Теперь мы можем запустить проект короткой командой `uv run <точка-входа>`:
#Shell 
```
uv run my-app
Welcome to my application!
```
## Точка входа для библиотеки
Точка входа в приложениях - место, где происходит вызов самого приложения в виде функции или какого-то кода, однако, в библиотеках мы не должны в обычной ситуации вызывать код.

Библиотека предоставляет функцию или набор функций, а когда их вызывать решает тот, кто импортирует библиотеку в свой модуль

Пример использования функций из библиотеки:
```python
from more_itertools import sliced, substrings

subs = ["".join(s) for s in substrings("more")]
print(subs)

slices = list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))
print(slices)
```
- Мы не указываем путь до до конкретного файла, а только указываем название библиотеки. Для таких приколов с импортом в своих модулей без указания полного пути необходимо экспортировать "наружу", на верхний уровень библиотеки необходимые функции или целые модули, это делается в файле `__init__.py`
- Обычная задача модуля `__init__.py` в том, чтобы указывать интерпретатору, что директория с файлами это пакет для оперирования импортами. В этом же файле можно перечислить функции, которые мы хотим экспортировать "наружу", после чего мы сможем использовать их в других модулях

```python
# мы также можем импортировать под другим именем через as
import my_application.module as my_lib
from my_application.module import greet

__all__ = (
    "my_lib",
    "greet",
)
```
- Сперва мы импортируем необходимые нам функции или целые модули. Затем вписываем кортеж из них в еще одну особую переменную `__all__`.

Теперь, тем, кто будет использовать эту библиотеку, не нужно знать в каком файле определены функции. При импорте нашей библиотеки, экспортируется все перечисленное в `__all__`.
```python
from my_application import my_lib, greet

my_lib.greet()
# => Welcome to my application!

greet()
# => Welcome to my application!
```
Подобный файл с экспортами функций и модулей для пользования нашей библиотекой называют **фасадом**.

**Фасад** - init-файл, который экспортирует нужные функции "наружу", которые затем можно использовать как импортируемый модуль или функции из него

## Дополнительные материалы

- [Совершенный код: проектирование функций](https://ru.hexlet.io/blog/posts/sovershennyy-kod-proektirovanie-funktsiy)