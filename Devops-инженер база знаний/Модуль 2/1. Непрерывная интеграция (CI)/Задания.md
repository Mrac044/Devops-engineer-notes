#Скрипт По умолчанию задания запускаются параллельно, но если нужно, то их можно упорядочивать:
```
# сборка фронтенда и бекенда происходит одновременно
# а тесты бекенда запускаются только после сборки бекенда
jobs:
  build-frontend:
  build-backend:
  test:
    needs: build-backend
```

Задание test запустится только в том случае, если build-backend завершился без ошибок, что задается строчкой `needs: build-backend` 

**Нотификация** в контексте заданий в GitHub Actions — это запуск дополнительного задания, которое выполняется независимо от результата предыдущих заданий и предназначено для уведомления, например, о завершении сборки или тестирования.

#Скрипт Для этого добавляется специальная конструкция через ключ `if`:

```
jobs:
  build-frontend:
  build-backend:
  test:
    # конструкция внутри ${{}} называется выражением
    if: ${{ always() }}
    needs: build-backend
```

==Простыми словами: `needs` - лишь указывает, после чего выполняется задание, по умолчанию, если задание, указанное в `needs` было выполнено с ошибкой, то задание, в котором состоит этот блок `needs` выполнено не будет. 
НО
Если мы добавляем в `needs` указанное выше условие, то задание, в котором состоит блок `needs` будет выполнено и пофек как выполнилось задание указанное в `needs`, по умолчанию, если бы задание в `needs` выполнилось бы с ошибкой, то всё задание, где стоит блок `needs` скипнулось бы.==

По умолчанию задания изолированны друг от друга, и если мы делаем сборку в одном задании, то использовать собранные файлы в другом мы не сможем, решения для этого:

- Если проектик простой, то достаточно будет одного задания, которое сразу будет делать всё, и репозиторий клонировать и устанавливать зависимости и тесты запускать:
#Скрипт
```
# Пример для проекта на Node.js
jobs:
  build: # имя взято для примера
    runs-on: ubuntu-latest

    steps:
      # Клонируем репозиторий
      - uses: actions/checkout@v4
      # Устанавливаем Node.js
      - uses: actions/setup-node@v4
      # Ставим зависимости
      - run: npm install
      # Запускаем линтер
      - run: npm run lint
      # Запускаем тесты
      # у шагов может быть имя, иногда это помогает отладке
      # имя выводится на Github при просмотре сборки
      - name: run tests
        run: npm test # name и run относятся к одной задаче, поэтому дефис ставится только перед name
```
Каждый шаг задания запускается в одной и той же директории. Туда же клонируется репозиторий экшеном _checkout_.

- Дополнительно [включать шаги](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/passing-information-between-jobs):
1. Откройте файл воркфлоу, содержащий задание, результаты которого вы хотите передать другому заданию.

2. #Скрипт Используйте синтаксис `jobs.<job_id>.outputs` для определения выходных данных задания. Например, в следующем задании определены выходные данные `output1` и `output2`, которые сопоставляются с результатами `step1` и `step2` соответственно:

    ```yaml
    jobs:
      job1:
        runs-on: ubuntu-latest
        outputs:
          output1: ${{ steps.step1.outputs.test }}
          output2: ${{ steps.step2.outputs.test }}
        steps:
          - id: step1
            run: echo "test=hello" >> "$GITHUB_OUTPUT"
          - id: step2
            run: echo "test=world" >> "$GITHUB_OUTPUT"
    ```
    
3. #Скрипт В отдельном задании, где вам нужно получить доступ к этим результатам, используйте синтаксис `jobs.<job_id>.needs`, чтобы сделать его зависимым от исходного задания. Например, следующее задание проверяет, завершено ли `job1` перед запуском:
    
    ```yaml
    jobs:
      # Assume job1 is defined as above
      job2:
        runs-on: ubuntu-latest
        needs: job1
    ```
    
3. #Скрипт Чтобы получить доступ к выходным данным в зависимом задании, используйте синтаксис `needs.<job_id>.outputs.<output_name>` . Например, следующее задание обращается к выходным данным `output1` и `output2`, определённым в `job1`:
    
    ```yaml
    jobs:
      # Assume job1 is defined as above
      job2:
        runs-on: ubuntu-latest
        needs: job1
        steps:
          - env:
              OUTPUT1: ${{needs.job1.outputs.output1}}
              OUTPUT2: ${{needs.job1.outputs.output2}}
            run: echo "$OUTPUT1 $OUTPUT2"
    ```
    

## [Дальнейшие действия](https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/pass-job-outputs#next-steps)

Чтобы узнать больше о результатах выполнения задания и контексте `needs`, ознакомьтесь со следующими разделами [синтаксиса рабочего процесса для GitHub Actions](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idoutputs):

- [`jobs.<job_id>.outputs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idoutputs)
- [`jobs.<job_id>.needs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idneeds)

## Операционная система

==Github Actions позволяет выбрать одну из трех операционных систем: Ubuntu, Windows и MacOS . Все возможные варианты перечислены на [специальной странице](https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners#standard-github-hosted-runners-for-public-repositories).==

Если хотите проводить тесты на разные операционках:
- Создать идентичные задания под каждую операционную систему, но можно лучше.
- В Github Actions встроена возможность описать одно задание так, чтобы оно запускалось для разных версий операционных систем, языков и так далее:

```
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
      # тут шаги
```

## Переменные окружения

С помощью ключа `env` можно добавить переменные окружения, доступные для всех шагов текущего задания:

```
jobs:
  run:
    env:
      RAILS_ENV: staging
      DEBUG: 1
```

Довольно много полезных переменных окружения [добавлено сразу](https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables). Вот как их можно использовать прямо в шагах:

```
steps:
  - run: echo "Имя текущего воркфлоу – $GITHUB_WORKFLOW"
```
## Дополнительные материалы

- [Запуск сервисов](https://docs.github.com/en/actions/using-containerized-services/about-service-containers)