Вопрос производительности базы данных и запросов к ней с течением времени становится все актуальнее.

## EXPLAIN

SQL — это декларативный язык, то есть им мы описываем **ЧТО** хотим получить, а не **КАК**. Но это не устраивает машину, так как СУБД должна знать, каким образом добраться до этих данных.

В СУБД реализована подсистема, которая называется **планировщик** или **scheduler**. Она строит **план запроса** — описывает, как будут извлекаться данные, которые хранятся внутри базы.

#SQL-команда Результат работы планировщика можно посмотреть командой `EXPLAIN`:

```sql
EXPLAIN SELECT * FROM users
  JOIN topics ON users.id = topics.user_id
  WHERE users.created_at > '10.10.2018';

                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Hash Join  (cost=10.66..23.59 rows=42 width=2377)
   Hash Cond: (topics.user_id = users.id)
   ->  Seq Scan on topics  (cost=0.00..11.30 rows=130 width=572)
   ->  Hash  (cost=10.50..10.50 rows=13 width=1805)
         ->  Seq Scan on users  (cost=0.00..10.50 rows=13 width=1805)
               Filter: (created_at > '2018-10-10 00:00:00'::timestamp without time zone)
(6 rows)
```

Подробнее про план читайте в статье [Производительность запросов в PostgreSQL — шаг за шагом](https://habr.com/company/oleg-bunin/blog/319018/).

## Индексы

План запроса можно использовать по-разному, например: переписать или разбить запрос на более эффективный. Некоторые запросы уже достаточно оптимизированы, поэтому для их ускорения используют **индексы** — специальную структуру внутри базы данных, которая создается, чтобы ускорить поиск. #SQL-команда Индекс в базе данных подобен предметному указателю в любой книге:

```sql
-- Пример создания индекса по полю birthday таблицы users
CREATE INDEX ON users(birthday);
```

Этот запрос создает индекс на таблице `users` по полю `birthday`. Теперь запросы с условием или сортировкой по `birthday` будут работать быстрее за счет использования индекса во время подготовки данных. Пример:

```sql
SELECT * from users WHERE birthday = '2000-01-01';
```

В PostgreSQL встроено шесть разных видов индексов, которые подходят под разные ситуации. Для работы с ними нужно понимать несколько вещей:

- Устройство индексов. Здесь не обойтись без знания **структур данных и алгоритмов**. В первую очередь речь идет про **сбалансированные деревья** — btree
- Классификацию видов запросов. Например, запрос по диапазону или запрос с применением `LIKE` оператора — разные виды запросов, которые по-разному работают и оптимизируются
- Влияние различных конструкций SQL на план запроса. Например, `ORDER BY` — дорогая операция, которая часто приводит к полному перебору таблицы

## Денормализация

>Еще один подход для оптимизации называется **денормализацией** — процесс, обратный нормализации.

В реляционной теории такого понятия нет и оно противоречит ее идеям. #Реальная_работа Но на практике этот способ активно применяется, так как за счет избыточности позволяет упростить запросы, так как данные ближе и их легче извлечь.

>Цена за денормализацию — дополнительный объем и иногда необходимость производить синхронизацию данных самостоятельно. Например, мы можем хранить имя пользователя в разных таблицах, что создает сложности, когда оно изменяется. Поэтому его нужно поменять во всех таблицах, где оно используется. 

==Денормализация значительно сокращает число запросов с соединениями — joins.==

#Собеседования Мы разобрали основные подходы оптимизации базы данных. Подобный вопрос редко касается новичков, но, например, на собеседовании иногда спрашивают на эту тему. Если вы дадите хороший ответ, то у вас будет больше шансов на трудоустройство.

## Дополнительные материалы

- [Типы индексов в PostgreSQL](https://postgrespro.ru/docs/postgresql/15/indexes-types)
    
- [B-дерево](https://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)
    
- [Продуманная оптимизация](http://optimization.guide/)
