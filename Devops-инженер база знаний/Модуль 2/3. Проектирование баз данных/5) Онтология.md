Программы, которые пишут программисты, всегда создаются под определенную предметную область. Например, бухгалтерский софт основывается на правилах ведения бухгалтерского учета, а сайт для просмотра сериалов — на таких понятиях из телеиндустрии, как «сезон» или «эпизод».
## Что такое онтология

Эти связи имеют конкретные названия:

- **Один ко многим**, **one-to-many** или **o2m**. Например, когда один урок может находиться только в одном курсе, но курс содержит множество уроков
    
- **Один к одному**, **one-to-one** или **o2o**. Например, на Хекслете такая связь установлена между пользователем и аккаунтом на Facebook
    
- **Многие ко многим**, **many-to-many** или **m2m**. Например, когда один курс могут проходить много пользователей, и один пользователь может проходить много курсов
![[Pasted image 20260209124711.png]]

>Описание объектов рассматриваемой области и связей между ними называется **онтологией** предметной области.

#Реальная_работа На практике программисты, бизнес-аналитики или менеджеры общаются с заказчиками, которые могут сами выступать в роли экспертов, и строят вместе с ними формальную онтологию.

Затем с помощью [ER-модели](https://ru.wikipedia.org/wiki/ER-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C) программист формирует необходимую модель данных. Необязательно на бумаге или в специализированных программах. Чаще такая модель существует только в голове и коде.

Эта модель и становится основной для проектирования базы данных. Каждая сущность в реляционной базе данных представлена таблицей, а связи между сущностями реализуются через внешние ключи.

Чтобы визуализировать ER-модель, используют диаграмму Entity-Relationship Diagram (ERD).

## Что такое ERD

Многие понимают под ER-моделью и ERD одно и то же. Хотя ER-модель можно представить и с помощью других нотаций.
*У ER-модели нет графического представления, поэтому используют ERD.*
![[Pasted image 20260209184706.png]]

### Один ко многим (one-to-many)

Один ко многим — наиболее распространенный вид связи. Например, один лектор может вести несколько курсов:
![[Pasted image 20260209184746.png]]
Технически, такая связь организуется через внешний ключ, который добавляется в зависимую сущность — many.

Допустим, у нас есть две исходные таблицы:

**users**

|id|first_name|last_name|created_at|
|---|---|---|---|
|1|Сергей|Петров|11.10.2005|
|38|Иван|Носов|03.08.2000|
|22|Виктор|Пирогов|23.12.2011|

**emails**

|id|user_id|email|
|---|---|---|
|1|1|[serj@gmail.com](mailto:serj@gmail.com)|
|2|1|[petrov@mail.ru](mailto:petrov@mail.ru)|
|10|38|[ivan@yahoo.com](mailto:ivan@yahoo.com)|
|22|22|[vkurg@indbox.com](mailto:vkurg@indbox.com)|

Чтобы узнать все адреса почты, которые есть у пользователя с идентификатором `1`, нужно выполнить такой запрос:

```
SELECT * FROM emails WHERE user_id = 1;
```

|id|user_id|email|
|---|---|---|
|1|1|[serj@gmail.com](mailto:serj@gmail.com)|
|2|1|[petrov@mail.ru](mailto:petrov@mail.ru)|

[View on DB Fiddle](https://www.db-fiddle.com/f/8xTqkjcwTz3dLZRuRLgNdW/1)

### Один к одному (one-to-one)

![[Pasted image 20260209184843.png]]

Например, у каждой страны есть одна столица:

**countries**

|id|name|created_at|
|---|---|---|
|2|Russia|11.10.2005|
|38|Spain|03.08.2000|
|22|Germany|23.12.2011|

**cities**

|id|name|country_id|capital|created_at|
|---|---|---|---|---|
|34|Moscow|2|true|11.10.2005|
|33|Valencia|38||03.08.2000|
|99|Voronezh|2||23.12.2011|
|4|Ulyanovsk|2||23.12.2011|
|5|Berlin|22|true|23.12.2011|
|20|Madrid|38|true|23.12.2011|

Связь one-to-one обычно существует не сама по себе, а внутри связи one-to-many. То есть у каждой страны есть города, но только один из них столица.

```
SELECT * FROM cities WHERE country_id = 38 AND capital = true;
```

[View on DB Fiddle](https://www.db-fiddle.com/f/8xTqkjcwTz3dLZRuRLgNdW/8)

### Многие ко многим (many-to-many)

![[Pasted image 20260209184917.png]]

Технически невозможно связать две таблицы связью many-to-many без введения третьей таблицы.

Например, у нас есть две исходные таблицы:

**users**

|id|first_name|created_at|
|---|---|---|
|2|Сергей|11.10.2005|
|38|Иван|03.08.2000|
|22|Виктор|23.12.2011|

**courses**

|id|name|created_at|
|---|---|---|
|8|PHP basics|11.10.2005|
|55|Python basics|03.08.2000|
|22|Ruby basics|23.12.2011|

Эта таблица будет связующей:

**course_members**

|id|user_id|course_id|created_at|
|---|---|---|---|
|34|2|8|11.10.2005|
|33|38|55|03.08.2000|
|99|22|22|23.12.2011|
|4|22|8|23.12.2011|
|5|38|22|

Если мы захотим узнать все курсы, которые проходит пользователь, то выполним такой запрос:

```sql
SELECT course_id FROM course_members WHERE user_id = 22;
```

Если захотим узнать, кто проходит данный курс, то такой запрос:

```sql
SELECT user_id FROM course_members WHERE course_id = 22;
```

[View on DB Fiddle](https://www.db-fiddle.com/f/c1W2Y73DhvsoS1Nx8qkHVv/6)

В общем виде схема выглядит так:

Есть исходные таблицы _A_ и _B_. Для них создается новая таблица _AB_. Внутри нее есть два внешних ключа — _a_id_ и _b_id_, которые связаны с исходными таблицами.

## Выводы

В реляционных базах данных используют три типа связи: один ко многим, один к одному и многие ко многим. А визуализируются они с помощью Entity-Relationship Diagram.

## Дополнительные материалы

- [Онтология (информатика)](https://ru.wikipedia.org/wiki/%D0%9E%D0%BD%D1%82%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F_\(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0\))
