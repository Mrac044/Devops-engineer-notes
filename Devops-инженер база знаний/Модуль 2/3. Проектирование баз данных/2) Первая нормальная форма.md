## Нормальная форма

**Таблица order_items**

| first_name | last_name | address                  | item                             | price                               |
| ---------- | --------- | ------------------------ | -------------------------------- | ----------------------------------- |
| Сергей     | Иванов    | Москва, ул. Промышленная | утюг                             | 15.00 ==цена в долларах==           |
| Иван       | Петров    | Самара, ул. Энгельса     | кофеварка                        | 5000.00                             |
| Виктор     | Сидоров   | Омск, ул. Дворцовая      | утюг, телевизор ==два значения== | 1000.00, 6500.00                    |
| Сергей     | Иванов    | Москва, ул. Матросова    | ноутбук                          | 20000.00                            |
| Сергей     | Иванов    | Москва, ул. Матросова    | ноутбук                          | 20000.00<br>==повтор строчки выше== |

[View on DBFiddle](https://www.db-fiddle.com/f/kFc7ySCXoDsAQUVVJdjU3v/0)

В этой табличке много повторяющейся информации. 
Приведем ее к правильной структуре с точки зрения реляционной модели. Для этого приведем данные к 
>**нормальной форме**  — это требования, которые минимизируют избыточность данных, потенциально приводящих к логическим ошибкам.

*Всего существует шесть нормальных форм, которые включают определенные требования.*

## Первая нормальная форма

Первая нормальная форма сводится к трем правилам:

- Каждая ячейка таблицы может хранить только одно значение
- Все данные в одной колонке могут быть только одного типа
- Каждая запись в таблице должна однозначно отличаться от других записей

### Каждая ячейка – одно значение

У одной записи поля _item_ и _price_ содержат два значения через запятую. У такого способа организации данных много недостатков. Например, пропадает возможность делать обычную выборку по условиям:

```sql
-- Как найти записи о всех проданных утюгах?
SELECT * FROM order_items WHERE item = "?";
```
Становится проблематично выполнить агрегирующие запросы

Чтобы избавиться от перечислений в ячейках, можно создать новые записи:

| first_name | last_name | address                  | item      | price                               |
| ---------- | --------- | ------------------------ | --------- | ----------------------------------- |
| Сергей     | Иванов    | Москва, ул. Промышленная | утюг      | 15.00<br>==цена в долларах==        |
| Иван       | Петров    | Самара, ул. Энгельса     | кофеварка | 5000.00                             |
| Виктор     | Сидоров   | Омск, ул. Дворцовая      | утюг      | 1000.00                             |
| Виктор     | Сидоров   | Омск, ул. Дворцовая      | телевизор | 6500.00                             |
| Сергей     | Иванов    | Москва, ул. Матросова    | ноутбук   | 20000.00                            |
| Сергей     | Иванов    | Москва, ул. Матросова    | ноутбук   | 20000.00<br>==повтор строчки выше== |
Так мы избавились от перечислений в поле, что позволит выполнять агрегирующие запросы, а также не будет путаницы с типами данных.

### Данные одного типа

И доллары, и рубли представлены числами, но с точки зрения программы у этих чисел разная природа.

Разные данные в рамках одного поля тоже не дают выполнить агрегирующие запросы, например, поиск сумм, максимального, минимального. Еще усложняется обработка данных на уровне кода. В коде придется каким-то образом понимать, что из себя представляют данные.

Вот еще несколько примеров с похожей ситуацией:

- Хранение даты свадьбы в поле «день рождения»
- Хранение номера телефона вместо адреса в поле «адрес»

Исправленная версия таблицы:

| first_name | last_name | address                  | item      | price                               |
| ---------- | --------- | ------------------------ | --------- | ----------------------------------- |
| Сергей     | Иванов    | Москва, ул. Промышленная | утюг      | 1000.00                             |
| Иван       | Петров    | Самара, ул. Энгельса     | кофеварка | 5000.00                             |
| Виктор     | Сидоров   | Омск, ул. Дворцовая      | утюг      | 1000.00                             |
| Виктор     | Сидоров   | Омск, ул. Дворцовая      | телевизор | 6500.00                             |
| Сергей     | Иванов    | Москва, ул. Матросова    | ноутбук   | 20000.00                            |
| Сергей     | Иванов    | Москва, ул. Матросова    | ноутбук   | 20000.00<br>==повтор строчки выше== |
Теперь у данных в поле _price_ один тип. Так программе будет легче выполнять агрегирующие запросы.

### Уникальные записи

Последние две записи в таблице выглядят идентично, хотя это два разных заказа. Их сделал один человек, но в разное время:

|first_name|last_name|address|item|price|
|---|---|---|---|---|
|Сергей|Иванов|Москва, ул. Матросова|ноутбук|20000.00|
|Сергей|Иванов|Москва, ул. Матросова|ноутбук|20000.00|
Реализовать уникальность можно несколькими способами:
- добавить новое поле с датой заказа (не очень надёжный и удобный, придется анализировать весь набор полей)
- добавить первичный ключ (PRIMARY KEY или индекс(id)), он не может меняться и его значение однозначно

Разберем два вида первичного ключа:
- **Естественный** — когда используются значения из окружающего мира, например, email, ФИО или паспортные данные. Такие первичные ключи используют редко из-за их ненадежности. Часто они не уникальны и могут изменяться или повторяться. Например, номер паспорта меняется при смене документа
- **Суррогатный** — когда используются автоматически генерируемые уникальные значения. Такой ключ поддерживается любой базой данных «из коробки». Иногда это просто числа, а иногда — сложные число-буквенные строки или хеши

Добавим в нашу таблицу первичный ключ:

|id|first_name|last_name|address|item|price|
|---|---|---|---|---|---|
|8|Сергей|Иванов|Москва, ул. Промышленная|утюг|1000.00|
|2|Иван|Петров|Самара, ул. Энгельса|кофеварка|5000.00|
|7|Виктор|Сидоров|Омск, ул. Дворцовая|утюг|1000.00|
|4|Виктор|Сидоров|Омск, ул. Дворцовая|телевизор|6500.00|
|9|Сергей|Иванов|Москва, ул. Матросова|ноутбук|20000.00|
|6|Сергей|Иванов|Москва, ул. Матросова|ноутбук|20000.00|

#SQL-команда Первичный ключ принято создавать первым полем с названием _id_. Для первичного ключа обязательно указывать _PRIMARY KEY_ в описании таблицы:

```sql
-- Первичный ключ только один на таблицу
CREATE TABLE products (
    id bigint PRIMARY KEY,
    first_name varchar(255),
    last_name varchar(255),
    address varchar(255),
    item varchar(255),
    price numeric -- специальный тип данных, который подходит под работу с деньгами. Обеспечивает высокую точность при расчетах.
);
```

[View on DBFiddle](https://www.db-fiddle.com/f/borpbYcu7c1dnkuecawvL1/1)

## Выводы

В этом уроке мы узнали, что такое нормальная форма в реляционной модели. Она помогает облегчить считываемость информации в таблице. Еще мы подробно разобрали первый уровень формы. Так мы узнали, что каждая ячейка таблицы может хранить только одно значение. Иначе может произойти путаница с типами данных, из-за чего будет невозможно проверить их корректность.

Также все данные в одной колонке могут быть только одного типа. Данные разного типа усложняют работу с таблицей, так как в коде придется каким-то образом понимать, что из себя представляют данные. А чтобы отличать записи друг от друга, нужно использовать суррогатный первичный ключ, который сделает каждую запись уникальной.

## Дополнительные материалы

- [Первичный ключ](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B2%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BB%D1%8E%D1%87)
    
- [Внешний ключ](https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D1%88%D0%BD%D0%B8%D0%B9_%D0%BA%D0%BB%D1%8E%D1%87)
    
- [Суррогатный ключ](https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D1%80%D1%80%D0%BE%D0%B3%D0%B0%D1%82%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BB%D1%8E%D1%87)