Не все операции с базой данных можно выразить одним запросом. Например, так нельзя сделать с транзакцией, когда нужно перевести деньги с одного счета на другой.

## Запросы внутри транзакции

Допустим, у нас есть таблица счетов _accounts_, в которой две записи:

|id|user_id|amount|
|---|---|---|
|1|10|100|
|2|30|100|

[View on DB Fiddle](https://www.db-fiddle.com/f/eM6zY9ZPatH4HabtX67pYV/1)

Процесс перевода можно представить так:

1. Получаем количество денег пользователя:
    
    ```sql
    SELECT amount FROM accounts WHERE user_id = 10;
    ```
    
2. Списываем необходимую сумму со счета этого пользователя:
    
    ```sql
    UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
    ```
    
3. Зачисляем деньги другому пользователю:
    
    ```sql
    UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;
    ```
    

В результате таблица примет следующий вид:

|id|user_id|amount|
|---|---|---|
|1|10|50|
|2|30|150|

[View on DB Fiddle](https://www.db-fiddle.com/f/eM6zY9ZPatH4HabtX67pYV/2)

==Одна из проблем в этом процессе -- отсутствует гарантия завершения. Представим, что система успела выполнить списание, и в этот момент произошла ошибка, например, выключили питание или компьютер перезагрузился. В результате получится странная ситуация: деньги списались, но никуда не зачислились:==

| id  | user_id | amount |
| --- | ------- | ------ |
| 1   | 10      | 50     |
| 2   | 30      | 100    |

==Такое может произойти не только с деньгами, но и в большинстве других ситуаций. Приложения по возможности должны находиться в согласованном состоянии. В распределенных системах это невозможно, добиться этого можно с помощью механизма **транзакций**. Мы не будем подробно разбирать эту тему, но вы можете узнать о ней больше, изучив [CAP-теорему](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP) и [Eventual Consistency](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B2_%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D0%BE%D0%BC_%D1%81%D1%87%D1%91%D1%82%D0%B5).==

Мы ожидаем от любой подобной транзакции **атомарность** -- когда операция либо завершается успешно, либо не проходит. Транзакции в базе данных в этом смысле проще, чем бизнес-транзакции. За обеспечением необходимых гарантий следит сама СУБД, а не программист:

```sql
BEGIN;
SELECT amount FROM accounts WHERE user_id = 10;
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;
COMMIT;
```

[View on DB Fiddle](https://www.db-fiddle.com/f/eM6zY9ZPatH4HabtX67pYV/3)

#SQL-команда **Транзакции в PostgreSQL** -- это блок запросов, который обрамляется запросами:

- `BEGIN` -- открытие транзакции
- `COMMIT` -- закрытие транзакции

Любая ошибка внутри транзакции откатывает все изменения, которые были сделаны после запроса `BEGIN`:
![[Pasted image 20260208000803.png]]

#SQL-команда Если нужно, транзакцию можно откатить самостоятельно. Для этого необходимо выполнить запрос `ROLLBACK` до `COMMIT`. Это нужно, когда выполняются запросы из кода приложения.

```sql
BEGIN;
UPDATE accounts SET amount = amount - 50 WHERE user_id = 10;
ROLLBACK;
```

[View on DB Fiddle](https://www.db-fiddle.com/f/eM6zY9ZPatH4HabtX67pYV/5)

## Требования к транзакционной системе
Также, чтобы транзакция была надежной и предсказуемой, нужно соблюдать определенные требования.

набор требований к транзакционной системе, которые гарантируют ее надежность -- **ACID**. К ним относятся:

- Atomicity (Атомарность)
- Consistency (Согласованность)
- Isolation (Изолированность)
- Durability (Устойчивость)

### Atomicity (Атомарность)

Любая транзакция не может быть частично завершена -- она либо выполнена, либо нет.

### Consistency (Согласованность)
Поддержка этого требования включает в себя ограничения (UNIQUE, NOT NULL)работу со стороны программистов, которые пишут необходимый для этого код.

- Завершившаяся транзакция должна сохранять согласованность базы данных.
- Гарантию согласованности данных нельзя полностью обеспечить только средствами базы данных
- В процессе транзакции данные могут быть несогласованы, но в итоге должны прийти к согласию

### Isolation (Изолированность)
Когда транзакция выполняется, параллельные транзакции не должны оказывать влияния на ее результат.

Изолированность -- дорогое требование, поэтому в реальных БД существуют режимы, которые изолируют транзакцию не полностью -- уровни изолированности **Repeatable Read** и ниже.

### Durability (Устойчивость)
Изменения, которые сделаны успешно завершенной транзакцией, должны остаться сохраненными после возвращения системы в работу. И это не должно зависеть от проблем на нижних уровнях

Если пользователь получил подтверждение от системы, что транзакция выполнена, он будет уверен, что ничего не отменится из-за какого-либо сбоя.

## Дополнительные материалы

- [Официальная документация](https://postgrespro.ru/docs/postgresql/15/tutorial-transactions)
    
- [ACID](https://ru.wikipedia.org/wiki/ACID)
    
- [Уровни изоляции транзакции](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9)